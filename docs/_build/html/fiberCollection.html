
<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" /><meta name="generator" content="Docutils 0.18.1: http://docutils.sourceforge.net/" />

    <title>&lt;no title&gt; &#8212; SPARCLE 1.0 documentation</title>
    <link rel="stylesheet" type="text/css" href="_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="_static/classic.css" />
    
    <script data-url_root="./" id="documentation_options" src="_static/documentation_options.js"></script>
    <script src="_static/doctools.js"></script>
    <script src="_static/sphinx_highlight.js"></script>
    <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="prev" title="Members" href="TemporalIntegrator.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="TemporalIntegrator.html" title="Members"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SPARCLE 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="PythonClasses.html" accesskey="U">Python Classes</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">&lt;no title&gt;</a></li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <dl class="py class">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fiberCollection.</span></span><span class="sig-name descname"><span class="pre">fiberCollection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nFibs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">turnovertime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fibDisc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonLocal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gam0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kbT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rigidFibs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>This is a class that operates on a list of fibers together.
This python class is basically a wrapper for the C++ class
FiberCollectionC.cpp, where every function is just calling the
corresponding (fast) C++ function.</p>
<p>An important variable throughout this class is self._nonLocal, which refers to
how the hydrodynamics is handled. There are currently 3 options:
nonLocal = 0: local drag only. This can include intra-fiber hydro depending on if
the fiberDiscretization object has FPIsLocal = True;
nonLocal = 1: full hydrodynamics (all fibers communicate with all fibers)
nonLocal = 4: only intra-fiber hydrodynamics. Depending on if FPIsLocal = True,
then this would be done using the same matrix as local drag OR if FPIsLocal = False,
the “finite part” velocity goes on the RHS of the saddle point system.</p>
<p>Another important function of this class is to keep SpatialDatabase objects inside
that can be used to query neighbors. All of these objects are currently “CellLinkedList,”
objects, which is a parallel CPU/GPU implementation of linked lists. (See SpatialDatabase.py
for documentation)</p>
<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nFibs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">turnovertime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fibDisc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonLocal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gam0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kbT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rigidFibs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for the fiberCollection class. This constructor initializes both the python and
corresponding C++ class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nFibs</strong> (<em>positive int</em>) – The number of fibers</p></li>
<li><p><strong>turnovertime</strong> (<em>double</em>) – Mean time for each fiber to turnover</p></li>
<li><p><strong>fibDisc</strong> (<em>FibCollocationDiscretization object</em>) – The discretization object that each fiber will get a copy of,</p></li>
<li><p><strong>nonLocal</strong> (<em>integer</em>) – The type of hydrodynamics (0 for local drag, 1 for full hydro, 4 for intra-fiber hydro only)</p></li>
<li><p><strong>mu</strong> (<em>double</em>) – The fluid viscosity</p></li>
<li><p><strong>omega</strong> (<em>double</em>) – The frequency of background flow oscillations</p></li>
<li><p><strong>gam0</strong> (<em>double</em>) – The base strain rate of the background flow</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em>) – Used to initialize the SpatialDatabase objects,</p></li>
<li><p><strong>kbT</strong> (<em>double</em>) – The thermal energy</p></li>
<li><p><strong>nThreads</strong> (<em>int</em><em> (</em><em>default is 1</em><em>)</em>) – The number of OMP threads for parallel calculations</p></li>
<li><p><strong>rigidFibs</strong> (<em>bool</em><em> (</em><em>default is False</em><em>)</em>) – Whether the fibers are rigid</p></li>
<li><p><strong>dt</strong> (<em>double</em><em>, </em><em>optional</em>) – Time step size (only for setting the tolerance in rigid Schur complement pseudo-inverse)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.initFibList">
<span class="sig-name descname"><span class="pre">initFibList</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fibListIn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">XFileName</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.initFibList" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the list of fibers. This is done by giving each fiber
a copy of the discretization object, and then initializing positions
and tangent vectors. This method inserts the fibers by giving them a random
center position and tangent vector, and therefore allows for possible
overlaps in the initial configuration.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fibListIn</strong> (<em>list</em>) – List of DiscretizedFiber objects. Typically empty, and filled in this method.</p></li>
<li><p><strong>Domain</strong> (<em>Domain object</em>) – The periodic domain used to initialize the fibers</p></li>
<li><p><strong>XFileName</strong> (<em>string</em><em>, </em><em>optional</em>) – If the positions are being read in from a file, this string gives the name
of the file to read</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.RSAFibers">
<span class="sig-name descname"><span class="pre">RSAFibers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">fibListIn</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">StericEval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nDiameters</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.RSAFibers" title="Permalink to this definition">¶</a></dt>
<dd><p>Initialize the list of fibers. This method inserts the fibers using
random sequential addition, meaning the fibers will not overlap.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>fibListIn</strong> (<em>list</em>) – List of DiscretizedFiber objects. Typically empty, and filled in this method.</p></li>
<li><p><strong>Domain</strong> (<em>Domain object</em>) – The periodic domain used to initialize the fibers</p></li>
<li><p><strong>StericEval</strong> (<em>StericForceEvaluator object</em>) – Used to compute overlaps between the fibers in random sequential addition</p></li>
<li><p><strong>nDiameters</strong> (<em>double</em><em>, </em><em>defaults to 1</em>) – The number of diameters apart we want the centerlines of the fibers to be. This
method guarantees that no pair of fibers will be less than nDiameters apart.</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.initPointForceVelocityArrays">
<span class="sig-name descname"><span class="pre">initPointForceVelocityArrays</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.initPointForceVelocityArrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to initialize the memory for lists of points, tangent
vectors and lambdas for the fiber collection</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Domain</strong> (<em>Domain object</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.fillPointArrays">
<span class="sig-name descname"><span class="pre">fillPointArrays</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.fillPointArrays" title="Permalink to this definition">¶</a></dt>
<dd><p>Copy the X and Xs arguments from self._fibList (list of fiber
objects) into large (tot#pts x 3) arrays that are stored in memory</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.formBlockDiagRHS">
<span class="sig-name descname"><span class="pre">formBlockDiagRHS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XNonLocal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">XLocal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">exForce</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lamstar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RPYEval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.formBlockDiagRHS" title="Permalink to this definition">¶</a></dt>
<dd><p>This method forms the RHS of the block diagonal saddle point system.
Specifically, the saddle point solve that we will eventually solve
can be written as
<div class="math notranslate nohighlight">
\[
B \alpha=M_LF+U_\textrm{Ex}
\]</div>

The point of this method is to return <span class="math notranslate nohighlight">\(F\)</span> (the forces) and <span class="math notranslate nohighlight">\(U_\textrm{Ex}\)</span> (the velocity
being treated explicitly).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>XNonLocal</strong> (<em>array</em>) – Chebyshev point locations for the nonlocal velocity evaluation</p></li>
<li><p><strong>XLocal</strong> (<em>array</em>) – Chebyshev point locations for the local velocity evaluation (can be different
depending on the temporal integrator being used)</p></li>
<li><p><strong>t</strong> (<em>double</em>) – time</p></li>
<li><p><strong>exForce</strong> (<em>array</em>) – The force being treated explicitly (e.g., gravity, cross linking forces)</p></li>
<li><p><strong>Lamstar</strong> (<em>array</em>) – The constraint forces Lambda for the nonlocal velocity calculation</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em>) – </p></li>
<li><p><strong>RPYEval</strong> (<em>RPYVelocityEvaluator object</em>) – Computes nonlocal velocities from forces</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair of arrays. The first contains the <span class="math notranslate nohighlight">\(F\)</span> = BendingForceMatrix*(XLocal)+exForce,
and the second contains the velocity
<span class="math notranslate nohighlight">\(U_\textrm{Ex}\)</span> = M_NonLocal*(Lamstar+exForce+BendingForceMatrix*(XNonLocal)) + U0, where U0
is the background flow</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(array,array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.calcResidualVelocity">
<span class="sig-name descname"><span class="pre">calcResidualVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">BlockDiagAnswer</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtimpco</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Lamstar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RPYEval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.calcResidualVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes the right hand side for the RESIDUAL system. The idea is that
we first solve a saddle point problem with a guess for the nonlocal force. We then
subtract that result from the system with the nonlocal force also treated implicitly
to get a system to solve. This is described in Section 7.3 in Maxian’s PhD dissertation.
Specifically, the RHS we are forming here is
<div class="math notranslate nohighlight">
\[
U = M_{NL} \left(F\left(X^n+\Delta t c K \alpha -X^{n+1/2,*}\right)+\Lambda-\Lambda^*\right)
\]</div>

where by <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> we mean the results from the block diagonal solver with the initial guess for
the nonlocal forcing.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>BlockDiagAnswer</strong> (<em>array</em>) – The answer for <span class="math notranslate nohighlight">\(\Lambda\)</span>$ and <span class="math notranslate nohighlight">\(\alpha\)</span> (in that order) from the block diagonal solver,</p></li>
<li><p><strong>dtimpco</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(\Delta t \times c\)</span>, here <span class="math notranslate nohighlight">\(c\)</span> is the implicit coefficient.
The implicit coefficient <span class="math notranslate nohighlight">\(c\)</span> depends on the
temporal integrator being used.</p></li>
<li><p><strong>Lamstar</strong> (<em>array</em>) – Guess for <span class="math notranslate nohighlight">\(\Lambda\)</span>$ from treating nonlocal forcing explicitly</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em><em>,</em>) – </p></li>
<li><p><strong>RPYEval</strong> (<em>RPYVelocityEvaluator object</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The right-hand side for GMRES. This has a block of velocities <span class="math notranslate nohighlight">\(U\)</span>
and then a block of zeros (for the second equation <span class="math notranslate nohighlight">\(K^T \Lambda=0\)</span>).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.CheckResiduals">
<span class="sig-name descname"><span class="pre">CheckResiduals</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LamAlph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">impcodt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RPYEval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">UAdd</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ExForces</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.CheckResiduals" title="Permalink to this definition">¶</a></dt>
<dd><p>This is just for debugging. It verifies that we solved the system we think we did.
What it does specifically is take <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> and compute
<div class="math notranslate nohighlight">
\[
U_1 = U_0+ M \left(\Lambda + \Delta t c K \alpha  + F_{in} \right)
\]</div>

where here <span class="math notranslate nohighlight">\(M\)</span> includes both the local and nonlocal parts,
and compare that result to <span class="math notranslate nohighlight">\(U_2 = K \alpha\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>LamAlph</strong> (<em>array</em>) – The answer for <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> (in that order)</p></li>
<li><p><strong>impcodt</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(\Delta t \times c\)</span>, here <span class="math notranslate nohighlight">\(c\)</span> is the implicit coefficient.
The implicit coefficient <span class="math notranslate nohighlight">\(c\)</span> depends on the
temporal integrator being used.</p></li>
<li><p><strong>X</strong> (<em>array</em>) – The Chebyshev points for the fibers</p></li>
<li><p><strong>Xs</strong> (<em>array</em>) – The tangent vectors for the fibers</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em><em>,</em>) – </p></li>
<li><p><strong>RPYEval</strong> (<em>RPYVelocityEvaluator object</em>) – </p></li>
<li><p><strong>t</strong> (<em>double</em>) – The system time</p></li>
<li><p><strong>UAdd</strong> (<em>array</em>) – Additional velocity (e.g., from stochastic terms)</p></li>
<li><p><strong>ExForces</strong> (<em>array</em>) – Forces being treated explicitly (e.g. cross-linking forces)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The residual <span class="math notranslate nohighlight">\(U_1-U_2\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.Mobility">
<span class="sig-name descname"><span class="pre">Mobility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LamAlph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">impcodt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RPYEval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.Mobility" title="Permalink to this definition">¶</a></dt>
<dd><p>Mobility calculation for GMRES. This method takes <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> and computes
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
-M \left(c \Delta t F K \alpha + \Lambda \right) \\
K^T \Lambda
\end{pmatrix}
\end{split}\]</div>

In other words, it computes the total forcing from <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\Lambda\)</span> (which
is given by <span class="math notranslate nohighlight">\(c \Delta t F K \alpha + \Lambda \)</span>) and then applies the TOTAL
(local and nonlocal) mobility to that</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>LamAlph</strong> (<em>array</em>) – The guess for <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> (in that order)</p></li>
<li><p><strong>impcodt</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(\Delta t \times c\)</span>, here <span class="math notranslate nohighlight">\(c\)</span> is the implicit coefficient.
The implicit coefficient <span class="math notranslate nohighlight">\(c\)</span> depends on the
temporal integrator being used.</p></li>
<li><p><strong>X</strong> (<em>array</em>) – The Chebyshev points for the fibers</p></li>
<li><p><strong>Xs</strong> (<em>array</em>) – The tangent vectors for the fibers</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em><em>,</em>) – </p></li>
<li><p><strong>RPYEval</strong> (<em>RPYVelocityEvaluator object</em>) – </p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array with two components: the first block is the velocity (see docstring above) and
the second block is <span class="math notranslate nohighlight">\(K^T \Lambda\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.FactorizePreconditioner">
<span class="sig-name descname"><span class="pre">FactorizePreconditioner</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_nonLoc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xs_nonLoc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">implic_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NBands</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">-1</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.FactorizePreconditioner" title="Permalink to this definition">¶</a></dt>
<dd><p>Factorize the diagonal solver. This is the first step in solving the saddle point system
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{matrix}
\left( K-\Delta t c M_LFK \right)\alpha = M_L \left(F_{ex} + \Lambda \right)+U_{ex} \\
K^T \Lambda = 0
\end{matrix}
\end{split}\]</div>

for <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span>. This corresponds to the matrix solve
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
-M_L &amp; K-\Delta t c M_LFK \\
K^T &amp;  0
\end{pmatrix}
\begin{pmatrix}
\Lambda \\
\alpha
\end{pmatrix}
=
\begin{pmatrix}
M_L F_{ex}+U_{ex} \\
0
\end{pmatrix}
\end{split}\]</div>

where <span class="math notranslate nohighlight">\(M_L\)</span> is the local mobility on each fiber separately (the argument NBands can
be used to make the mobility banded). The purpose of this method specifically is to form
the Schur complement of the matrix on the LHS above.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_nonLoc</strong> (<em>array</em>) – The Chebyshev points for the fibers</p></li>
<li><p><strong>Xs_nonLoc</strong> (<em>array</em>) – The tangent vectors for the fibers</p></li>
<li><p><strong>implic_coeff</strong> (<em>double</em>) – The implicit coefficient <span class="math notranslate nohighlight">\(c\)</span> for the
temporal integrator being used.</p></li>
<li><p><strong>dt</strong> (<em>double</em>) – time step size</p></li>
<li><p><strong>Nbands</strong> (<em>int</em><em>, </em><em>optional</em>) – The number of bands in the preconditioner (-1 uses all bands)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.BlockDiagPrecond">
<span class="sig-name descname"><span class="pre">BlockDiagPrecond</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">UNonLoc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ExForces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.BlockDiagPrecond" title="Permalink to this definition">¶</a></dt>
<dd><p>Solve the saddle point system given in the docstring of FactorizePreconditioner.
Here we pass in <span class="math notranslate nohighlight">\(F_{ex}\)</span> and <span class="math notranslate nohighlight">\(U_{ex}\)</span> and use the factorization from the previous method to
solve the saddle point system.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>UNonLoc</strong> (<em>array</em>) – The part of the velocity being treated explicitly (typically nonlocal velocity from other fibers)</p></li>
<li><p><strong>ExForces</strong> (<em>array</em>) – The forces being treated explicitly (or forces that don’t depend on <span class="math notranslate nohighlight">\(\alpha\)</span> or <span class="math notranslate nohighlight">\(\Lambda\)</span>
– typically bending forces at time <span class="math notranslate nohighlight">\(n\)</span> and cross linking forces)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The array <span class="math notranslate nohighlight">\((\Lambda,\alpha)\)</span> of forces and kinematic variables (the solution of the saddle
point system in the docstring of FactorizePreconditioner)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.BrownianUpdate">
<span class="sig-name descname"><span class="pre">BrownianUpdate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Randoms</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.BrownianUpdate" title="Permalink to this definition">¶</a></dt>
<dd><p>Random rotational and translational diffusion (assuming a rigid body) over time step dt.
This is for the special case when we can compute Brownian motion in a splitting step,
rather than using a special temporal integrator.
This function calls the corresponding C++ function, which computes a random rotation rate
<div class="math notranslate nohighlight">
\[
\alpha = \sqrt{\frac{2k_BT}{\Delta t}}N_{rig}^{1/2}W
\]</div>

where <span class="math notranslate nohighlight">\(W \sim \)</span>randn(0,1) and
<span class="math notranslate nohighlight">\(N_{rig} = \left(K_r^T M_L^{-1}K_r \right)^\dagger\)</span> is the rigid body mobility matrix.
It then rotates and translates by <span class="math notranslate nohighlight">\(\alpha\Delta t = (\Omega\Delta t , U\Delta t)\)</span>.
The inversion of the rigid mobility can be problematic because it is not well-posed for
fibers that are nearly-straight. We set a tolerance in the constructor using the expected
time step. Note that this is a void method, but it updates the internal variables to do the
Brownian motion.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>dt</strong> (<em>double</em>) – Time step size</p></li>
<li><p><strong>Randoms</strong> (<em>vector</em><em> of </em><em>doubles</em>) – Random <span class="math notranslate nohighlight">\(N\)</span>(0,1) numbers of size 6<span class="math notranslate nohighlight">\(\times\)</span> NFib (3 for rotation and 3 for translation)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.nonLocalVelocity">
<span class="sig-name descname"><span class="pre">nonLocalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">forces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RPYEval</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">subSelf</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.nonLocalVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the nonlocal velocity due to the fibers. This is the velocity
from hydrodynamics, plus the intra-fiber nonlocal velocity if the variable
self._FPLoc is false.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em>) – Fiber positions as Npts <span class="math notranslate nohighlight">\(\times\)</span> 3 array</p></li>
<li><p><strong>forces</strong> (<em>array</em>) – Forces as an 3*Npts 1D numpy array</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em>) – </p></li>
<li><p><strong>RPYEval</strong> (<em>RPYVelocityEvaluator object</em>) – </p></li>
<li><p><strong>subself</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether we subtract the self terms in the RPY velocity evaluator /
Ewald splitting step. The default is true, but in some instances (e.g., when the
self mobility is defined with oversampled RPY), the nonlocal mobility includes
the self mobility and as such we don’t need to subtract it.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The nonlocal velocity as a one-dimensional array.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.updateLambdaAlpha">
<span class="sig-name descname"><span class="pre">updateLambdaAlpha</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">lamalph</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.updateLambdaAlpha" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> internal variables after the solve is complete.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>Lamalph</strong> (<em>array</em>) – <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> obtained from the saddle point solve</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.updateAllFibers">
<span class="sig-name descname"><span class="pre">updateAllFibers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.updateAllFibers" title="Permalink to this definition">¶</a></dt>
<dd><p>Update the fibers using the Rodrigues rotation formula. The previous method sets the <span class="math notranslate nohighlight">\(\alpha\)</span>
parameter, which contains a tangent vector rotation rate <span class="math notranslate nohighlight">\(\Omega\)</span> and fiber midpoint velocity
<span class="math notranslate nohighlight">\(U_{mp}\)</span>. This update step is to first rotate the tangent vectors using the Rodrigues rotation
formula given in (6.72) of Maxian thesis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>dt</strong> (<em>double</em>) – Time step size</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>After updating the internal variables, it returns the maximum of the Chebyshev point positions
to check that the simulation is stable.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>double</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getX">
<span class="sig-name descname"><span class="pre">getX</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getX" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The Chebyshev point positions of all fibers</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getXs">
<span class="sig-name descname"><span class="pre">getXs</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getXs" title="Permalink to this definition">¶</a></dt>
<dd><dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The tangent vectors of all fibers</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.FiberStress">
<span class="sig-name descname"><span class="pre">FiberStress</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XBend</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">XLam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tau_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Volume</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.FiberStress" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute fiber stress. The formula for the deterministic
stress for a given force is
$$ \sigma = \frac{1}{V}\sum_j X_j F_j^T,$$
where <span class="math notranslate nohighlight">\(j\)</span> refers to the index of Chebyshev points and <span class="math notranslate nohighlight">\(V\)</span>
is the domain volume. This
method, being for the deterministic base class, computes the
stress due to the bending force and constraint force</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>XBend</strong> (<em>array</em>) – The locations to use to compute the bending force</p></li>
<li><p><strong>XLam</strong> (<em>array</em>) – The locations to use to compute the stress from <span class="math notranslate nohighlight">\(\Lambda\)</span>
(which is saved as an internal variable). In order for the
stress to be symmetric, these locations have to be the same
as the one used in the solve <span class="math notranslate nohighlight">\(K[X]^T \Lambda=0\)</span>, which means
they could be different from the bend locations.</p></li>
<li><p><strong>Tau_n</strong> (<em>array</em>) – Tangent vectors at time n. Not used in this base class.</p></li>
<li><p><strong>Volume</strong> (<em>double</em>) – The volume of the domain on which we are computing the stress.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Three 3 x 3 matrices of stress. The first is the stress
from the bend forces, the second the stress from <span class="math notranslate nohighlight">\(\Lambda\)</span>, and
the third is the stochastic drift stress (zero here).</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(array,array,array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.uniformForce">
<span class="sig-name descname"><span class="pre">uniformForce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">strengths</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.uniformForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Generate a uniform force on all fibers.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>strengths</strong> (<em>3-array</em>) – The strength of the uniform force</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of length 3*Nfib*<span class="math notranslate nohighlight">\(N_x\)</span> which simply
tiles the uniform force and assigns it to every
collocation point on every fiber</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getUniformPoints">
<span class="sig-name descname"><span class="pre">getUniformPoints</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chebpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getUniformPoints" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain uniform points from a set of Chebyshev points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>chebpts</strong> (<em>2D array</em>) – The Chebyshev points of the fibers, organized
into a  (tot#ofpts x 3) array</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>All fibers sampled at the uniform points. The number of
uniform points is given by self._fiberDisc._nptsUniform, and
is set in the constructor of this class.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>2D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getPointsForUpsampledQuad">
<span class="sig-name descname"><span class="pre">getPointsForUpsampledQuad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chebpts</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getPointsForUpsampledQuad" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain upsampled points for direct quadrature
from a set of Chebyshev points. This simply evaluates
the Chebyshev interpolant at the upsampled points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>chebpts</strong> (<em>2D array</em>) – The Chebyshev points of the fibers, organized
into a  (tot#ofpts x 3) array</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>All fibers sampled at the points for direct quadrature. The number of
uniform points is given by self._Ndirect, and
is set in the constructor of this class.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>2D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getForcesForUpsampledQuad">
<span class="sig-name descname"><span class="pre">getForcesForUpsampledQuad</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">chebforces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getForcesForUpsampledQuad" title="Permalink to this definition">¶</a></dt>
<dd><p>Obtain upsampled forces for direct quadrature
from a set of Chebyshev points. Unlike the method for
<span class="math notranslate nohighlight">\(X\)</span>, which evaluates the interpolant at a new set of Chebyshev
points, for forces the steps are more subtle. We need to
multiply by <span class="math notranslate nohighlight">\(\widetilde{W}^{-1}\)</span> to get force density from force,
then extend to an upsampled grid and multiply by weights. The
formula is therefore
<div class="math notranslate nohighlight">
\[F_{up} = W_{up} E_{up} \widetilde{W}^{-1} F,\]</div>

see (7.10) in Maxian’s PhD thesis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>chebforces</strong> (<em>2D array</em>) – The forces on the Chebyshev collocation points, organized
into a  (tot#ofpts x 3) array</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>All forces sampled at the points for direct quadrature. The number of
uniform points is given by self._Ndirect, and
is set in the constructor of this class.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>2D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getDownsampledVelocity">
<span class="sig-name descname"><span class="pre">getDownsampledVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">upsampledVel</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getDownsampledVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Downsample the velocity obtained on an upsampled grid. This turns out
to be the transpose of the force upsampling matrix discussed in the
previous method, so that we are computing
<div class="math notranslate nohighlight">
\[U = \widetilde{W}^{-1} E^T_{up} W^T_{up} U_{up},\]</div>

see (7.10) in Maxian’s PhD thesis.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>upsampledVel</strong> (<em>2D array</em>) – The velocities on the upsampled points points, organized
into a  (self._Ndirect*Nfib x 3) array</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The velocities at the Chebyshev points, using the multiplication above.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>2D array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getg">
<span class="sig-name descname"><span class="pre">getg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getg" title="Permalink to this definition">¶</a></dt>
<dd><p>Get the value of the strain g according to what the background flow dictates.
If the background flow is oscillatory (<span class="math notranslate nohighlight">\(\omega &gt; 0\)</span>), the strain (integral of
rate of strain) is given by
<div class="math notranslate nohighlight">
\[g = \frac{\gamma_0}{\omega} \sin{(\omega t)}.\]</div>

Otherwise, if <span class="math notranslate nohighlight">\(\omega=0\)</span>, we just have a constant shear flow and <span class="math notranslate nohighlight">\(g = \gamma_0 t\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>t</strong> (<em>double</em>) – The current time</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The non-dimensional strain <span class="math notranslate nohighlight">\(g\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>double</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getSysDimension">
<span class="sig-name descname"><span class="pre">getSysDimension</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getSysDimension" title="Permalink to this definition">¶</a></dt>
<dd><p>This method gives the total dimension of the saddle
point system. If the fibers are inextensible (but not rigid),
the dimension is <span class="math notranslate nohighlight">\(6 N_x F\)</span>, where <span class="math notranslate nohighlight">\(F\)</span> is the number of fibers,
since each collocation point gets a velocity and a constraint force.
If the fibers are rigid, the dimension is <span class="math notranslate nohighlight">\(3N_x F\)</span> (for the constraint
forces) <span class="math notranslate nohighlight">\(+ 6 F\)</span> (for rigid motions).</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>The dimension of the saddle point system (see docstring of
FactorizePreconditioner)</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>int</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.averageTangentVectors">
<span class="sig-name descname"><span class="pre">averageTangentVectors</span></span><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.averageTangentVectors" title="Permalink to this definition">¶</a></dt>
<dd><p>Computes the average tangent vectors along each fiber, which are
useful for analysis. It will return an array with nFib entries, where
each entry is given by
<div class="math notranslate nohighlight">
\[\tau_{avg} = \frac{1}{L} \int_0^L \tau(s) ds\]</div>
</p>
<dl class="field-list simple">
<dt class="field-odd">Returns<span class="colon">:</span></dt>
<dd class="field-odd"><p>Array of length nFib x 3, where each row <span class="math notranslate nohighlight">\(i\)</span> is the average tangent
vector of fiber <span class="math notranslate nohighlight">\(i\)</span>.</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.initializeLambdaForNewFibers">
<span class="sig-name descname"><span class="pre">initializeLambdaForNewFibers</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">newfibs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ExForces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">implic_coeff</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.initializeLambdaForNewFibers" title="Permalink to this definition">¶</a></dt>
<dd><p>This method solves a local problem to initialize values of lambda on the fibers
that were recently (add the current time step) birthed into the system. The
local problem we are solving is
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{matrix}
\left( K-\Delta t c M_LFK \right)\alpha = M_L \left(F_{ex} + F X + \Lambda \right)+U_{0} \\
K^T \Lambda = 0
\end{matrix}
\end{split}\]</div>

for <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span>. This corresponds to the matrix solve
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
-M_L &amp; K-\Delta t c M_LFK \\
K^T &amp;  0
\end{pmatrix}
\begin{pmatrix}
\Lambda \\
\alpha
\end{pmatrix}
=
\begin{pmatrix}
M_L \left(FX+F_{ex}\right)+U_0 \\
0
\end{pmatrix}
\end{split}\]</div>

where <span class="math notranslate nohighlight">\(M_L\)</span> is the local mobility on each fiber separately. Notice that
there is no nonlocal velocity here; only <span class="math notranslate nohighlight">\(U_0\)</span> is the RHS velocity. This makes
the problem relatively easy to solve.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>newfibs</strong> (<em>list</em>) – Indicies of fibers that were replaced / birthed in previous time step.</p></li>
<li><p><strong>ExForces</strong> (<em>array</em>) – The external forces (gravity or CL) applied to the fibers. This method will
compute the bending forces at time <span class="math notranslate nohighlight">\(n\)</span> internally. That said, because the
birthed fibers are always straight, the bending force is zero.</p></li>
<li><p><strong>t</strong> (<em>double</em>) – Current system time (to generate the background flow)</p></li>
<li><p><strong>dt</strong> (<em>double</em>) – Time step size <span class="math notranslate nohighlight">\(\Delta t\)</span></p></li>
<li><p><strong>implic_coeff</strong> (<em>double</em>) – The implicit coefficient <span class="math notranslate nohighlight">\(c\)</span> in the solve above.</p></li>
<li><p><strong>other</strong> (<em>optional</em><em>, </em><em>other fiberCollection object</em>) – This is used to also assign the values of <span class="math notranslate nohighlight">\(\Lambda\)</span> at the previous time
step, if we are doing Crank-Nicolson (we never do).</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Nothing, but updates the internal values of $$Lambda$ with the values computed in the
local solve.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>null</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.FiberBirthAndDeath">
<span class="sig-name descname"><span class="pre">FiberBirthAndDeath</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">tstep</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.FiberBirthAndDeath" title="Permalink to this definition">¶</a></dt>
<dd><p>Method for fiber turnover. This method computes the
fiber death rate for all fibers, then computes a time
for a fiber to die based on that (-log(1-rand)/rate).
As long as the time stays below <span class="math notranslate nohighlight">\(\Delta t\)</span>, the method keeps
choosing fibers uniformly at random to kill off.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>tstep</strong> (<em>double</em>) – Time step <span class="math notranslate nohighlight">\(\Delta t\)</span></p></li>
<li><p><strong>other</strong> (<em>optional</em><em>, </em><em>other fiberCollection object</em>) – This is used to also replace the locations at
the previous time step, if we are doing Crank-Nicolson</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A list of the indicies of all fibers that were replaced
during this time step.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>list</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.writeFiberLocations">
<span class="sig-name descname"><span class="pre">writeFiberLocations</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">FileName</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">wora</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">'a'</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.writeFiberLocations" title="Permalink to this definition">¶</a></dt>
<dd><p>Write the locations of all fibers to a file</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>FileName</strong> (<em>string</em>) – The name of the file to write to</p></li>
<li><p><strong>wora</strong> (<em>char 'a'</em><em> or </em><em>'w'</em>) – ‘a’ to append to an existing file (default),
‘w’ to write to a new file</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.SubtractSelfTerms">
<span class="sig-name descname"><span class="pre">SubtractSelfTerms</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Ndir</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xupsampled</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fupsampled</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">useGPU</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.SubtractSelfTerms" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the self integrals of the RPY kernel along a single fiber.
The reason for doing this is to subtract them from the result we
get when doing Ewald splitting, which necessarily gives the velocity
from all fibers on all others. Typically, we want to do the self
term as a separate calculation using some more accurate technique.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Ndir</strong> (<em>int</em>) – Number of points for direct quad (upsampled quadrature used in
Ewald splitting)</p></li>
<li><p><strong>Xupsampled</strong> (<em>array</em>) – Upsampled positions of Chebyshev points</p></li>
<li><p><strong>fupsampled</strong> (<em>array</em>) – Upsampled forces (not densities) on the Chebyshev points</p></li>
<li><p><strong>useGPU</strong> (<em>bool</em><em>, </em><em>optional</em>) – Whether to use a GPU to compute the self interactions
(default is false, as C++ is fast enough to not be even close to a
bottleneck)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The RPY direct sum on each Chebyshev point,
<div class="math notranslate nohighlight">
\[U_i =\sum_j M_{RPY}(X_i, X_j)F_j,\]</div>

where j and i are Chebyshev collocation points on the same fiber.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.LocalVelocity">
<span class="sig-name descname"><span class="pre">LocalVelocity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Forces</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.LocalVelocity" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the local velocity on each fiber. Given a vector of points
and forces, this method computes <div class="math notranslate nohighlight">
\[U = M_L[X]F.\]</div>
 The nature of <span class="math notranslate nohighlight">\(M_L\)</span>
is defined in the constructor of this class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em>) – Chebyshev point positions of all fibers as a (tot#ofpts*3) 1D array</p></li>
<li><p><strong>Forces</strong> (<em>array</em>) – The forces on all fibers, also as a 1D array</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The local velocity <span class="math notranslate nohighlight">\(M_L[X]F\)</span> on all fibers as a 1D array</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.evalU0">
<span class="sig-name descname"><span class="pre">evalU0</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">Xin</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.evalU0" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute the background flow on the Chebyshev points. Here we only
support a shear flow with strength <span class="math notranslate nohighlight">\(\gamma_0\)</span> and frequency <span class="math notranslate nohighlight">\(\omega\)</span>,
so that
<div class="math notranslate nohighlight">
\[U_0(x,y,z) = \gamma_0 \cos{\left(\omega t\right)} (y,0,0)\]</div>

(in the <span class="math notranslate nohighlight">\(x\)</span> direction).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>Xin</strong> (<em>array</em>) – An N x 3 array with each column being the x, y, and z locations of the
Chebyshev points at which we compute the flow</p></li>
<li><p><strong>t</strong> (<em>double</em>) – The time</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The background flow <span class="math notranslate nohighlight">\(U_0\)</span> as a 3N one-dimensional numpy array.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.evalBendForce">
<span class="sig-name descname"><span class="pre">evalBendForce</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_nonLoc</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.evalBendForce" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate the bending FORCES on the fibers by applying the
precomputed matrix <span class="math notranslate nohighlight">\(F\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X_nonLoc</strong> (<em>array</em>) – The Chebyshev point positions to evaluate the forces at.
The total length of this array is used to determine the number
of fibers involved.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The bending forces <span class="math notranslate nohighlight">\(FX\)</span> as a 3D numpy array.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.calcCurvatures">
<span class="sig-name descname"><span class="pre">calcCurvatures</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.calcCurvatures" title="Permalink to this definition">¶</a></dt>
<dd><p>Evaluate fiber curvatures on all fibers. Useful for analyzing
the results of simulations. The mean <span class="math notranslate nohighlight">\(L^2\)</span> curvature
<div class="math notranslate nohighlight">
\[
\sqrt{\frac{1}{L} \int_0^L X_{ss}(s) \cdot X_{ss}(s) ds }
\]</div>

is returned for each fiber.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>X</strong> (<em>array</em>) – The Chebyshev points of the fibers.</p>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array of length nFib with the mean <span class="math notranslate nohighlight">\(L^2\)</span> curvature by fiber</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getXInds">
<span class="sig-name descname"><span class="pre">getXInds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iFib</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getXInds" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to get the row indices in any (Nfib x Nperfib) x 3 2D arrays
of fiber position, for fiber number iFib.
This method could easily be modified to allow
for a bunch of fibers with different numbers of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>iFib</strong> (<em>int</em>) – The fiber index from 0 to NFib-1</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The indices of that fiber in an array of all the fiber positions</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getTauInds">
<span class="sig-name descname"><span class="pre">getTauInds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iFib</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getTauInds" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to get the row indices in any (Nfib x Nperfib) x 3 2D arrays
of fiber tangent vectors (different from positions) for fiber number iFib.
This method could easily be modified to allow
for a bunch of fibers with different numbers of tangent vectors.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>iFib</strong> (<em>int</em>) – The fiber index from 0 to NFib-1</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The indices of that fiber in an array of all the fiber tangent vectors</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.fiberCollection.getStackInds">
<span class="sig-name descname"><span class="pre">getStackInds</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">iFib</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.fiberCollection.getStackInds" title="Permalink to this definition">¶</a></dt>
<dd><p>Method to get the indices in any (Nfib*Nperfib*3) long 1D arrays
of fiber positions, for fiber number iFib.
This method could easily be modified to allow
for a bunch of fibers with different numbers of points.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><p><strong>iFib</strong> (<em>int</em>) – The fiber index from 0 to NFib-1</p>
</dd>
<dt class="field-even">Return type<span class="colon">:</span></dt>
<dd class="field-even"><p>The indices of that fiber in a stacked array of all the fiber positions</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="fiberCollection.SemiflexiblefiberCollection">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">fiberCollection.</span></span><span class="sig-name descname"><span class="pre">SemiflexiblefiberCollection</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nFibs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">turnovertime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fibDisc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonLocal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gam0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kbT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rigidFibs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.SemiflexiblefiberCollection" title="Permalink to this definition">¶</a></dt>
<dd><p>This class is a child of fiberCollection which implements BENDING FLUCTUATIONS.
There are some additional methods required in this case. In particular, we need
methods to compute the stochastic drift terms and Brownian velocity <span class="math notranslate nohighlight">\(M^{1/2}W\)</span></p>
<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.SemiflexiblefiberCollection.__init__">
<span class="sig-name descname"><span class="pre">__init__</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">nFibs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">turnovertime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">fibDisc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nonLocal</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">mu</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">omega</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">gam0</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">kbT</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nThreads</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">rigidFibs</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">0.001</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.SemiflexiblefiberCollection.__init__" title="Permalink to this definition">¶</a></dt>
<dd><p>Constructor for the fiberCollection class. This constructor initializes both the python and
corresponding C++ class.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>nFibs</strong> (<em>positive int</em>) – The number of fibers</p></li>
<li><p><strong>turnovertime</strong> (<em>double</em>) – Mean time for each fiber to turnover</p></li>
<li><p><strong>fibDisc</strong> (<em>FibCollocationDiscretization object</em>) – The discretization object that each fiber will get a copy of,</p></li>
<li><p><strong>nonLocal</strong> (<em>integer</em>) – The type of hydrodynamics (0 for local drag, 1 for full hydro, 4 for intra-fiber hydro only)</p></li>
<li><p><strong>mu</strong> (<em>double</em>) – The fluid viscosity</p></li>
<li><p><strong>omega</strong> (<em>double</em>) – The frequency of background flow oscillations</p></li>
<li><p><strong>gam0</strong> (<em>double</em>) – The base strain rate of the background flow</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em>) – Used to initialize the SpatialDatabase objects,</p></li>
<li><p><strong>kbT</strong> (<em>double</em>) – The thermal energy</p></li>
<li><p><strong>nThreads</strong> (<em>int</em><em> (</em><em>default is 1</em><em>)</em>) – The number of OMP threads for parallel calculations</p></li>
<li><p><strong>rigidFibs</strong> (<em>bool</em><em> (</em><em>default is False</em><em>)</em>) – Whether the fibers are rigid</p></li>
<li><p><strong>dt</strong> (<em>double</em><em>, </em><em>optional</em>) – Time step size (only for setting the tolerance in rigid Schur complement pseudo-inverse)</p></li>
</ul>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.SemiflexiblefiberCollection.formBlockDiagRHS">
<span class="sig-name descname"><span class="pre">formBlockDiagRHS</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X_nonLoc</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">t</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ExForces</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lamstar</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RPYEval</span></span><span class="o"><span class="pre">=</span></span><span class="default_value"><span class="pre">None</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.SemiflexiblefiberCollection.formBlockDiagRHS" title="Permalink to this definition">¶</a></dt>
<dd><p>This method forms the RHS of the block diagonal saddle point system.
Specifically, the saddle point solve that we will eventually solve
can be written as
<div class="math notranslate nohighlight">
\[
B \alpha=MF+U_0
\]</div>

The point of this method is to return <span class="math notranslate nohighlight">\(F\)</span> (the forces) and <span class="math notranslate nohighlight">\(U_\textrm{0}\)</span> (the velocity
being treated explicitly). Importantly, this method overwrites the one in
the deterministic class, because (at the moment), when we include fluctuations
the matrix <span class="math notranslate nohighlight">\(M\)</span> above includes ALL parts of the mobility, so that only velocity
that is treated explicitly in the background flow <span class="math notranslate nohighlight">\(U_0\)</span>.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X_nonLoc</strong> (<em>array</em>) – Chebyshev point locations for the velocity evaluation</p></li>
<li><p><strong>t</strong> (<em>double</em>) – time</p></li>
<li><p><strong>ExForces</strong> (<em>array</em>) – The force being treated explicitly (e.g., gravity, cross linking forces)</p></li>
<li><p><strong>lamstar</strong> (<em>array</em>) – The constraint forces <span class="math notranslate nohighlight">\(\Lambda^*\)</span> for the nonlocal velocity calculation (they do
not enter here, but are needed to keep consistency with parent class)</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em>) – Needed to keep consistency with parent class</p></li>
<li><p><strong>RPYEval</strong> (<em>RPYVelocityEvaluator object</em>) – Needed to keep consistency with parent class</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>A pair of arrays. The first contains the <span class="math notranslate nohighlight">\(F\)</span> = BendingForceMatrix*(X_nonLoc)+ExForces,
and the second contains the velocity <span class="math notranslate nohighlight">\(U_0\)</span> (the background flow)</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(array,array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.SemiflexiblefiberCollection.BrownianUpdate">
<span class="sig-name descname"><span class="pre">BrownianUpdate</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Randoms</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.SemiflexiblefiberCollection.BrownianUpdate" title="Permalink to this definition">¶</a></dt>
<dd><p>For semiflexible fluctuating filaments, the Brownian updates are included as part
of the temporal integrator (see methods listed below)
– we cannot split them into a separate step.
For this reason, this method, which is intended to only be used in the split
case, does nothing and outputs a warning.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.SemiflexiblefiberCollection.MHalfAndMinusHalfEta">
<span class="sig-name descname"><span class="pre">MHalfAndMinusHalfEta</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Ewald</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.SemiflexiblefiberCollection.MHalfAndMinusHalfEta" title="Permalink to this definition">¶</a></dt>
<dd><p>This method computes <span class="math notranslate nohighlight">\(M[X]^{1/2}W\)</span>, where <span class="math notranslate nohighlight">\(W \sim\)</span>randn(0,1) is
a random vector of i.i.d. Gaussian variables. The method we use to
compute this depends on what kind of hydrodynamics we have. If
self._nonLocal=1, we are doing fully nonlocal hydrodynamics, and
so we use the provided Ewald splitter argument to call PSE to
obtain <span class="math notranslate nohighlight">\(M^{1/2}W\)</span>. Otherwise, we have local hydrodynamics only,
and <span class="math notranslate nohighlight">\(M^{1/2}W\)</span> is generated fiber-by-fiber using dense linear algebra.
In this latter case, it becomes useful to also compute <span class="math notranslate nohighlight">\(M^{-1/2}W\)</span>
for later use in the drift term.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>X</strong> (<em>array</em>) – All of the Chebyshev points that are arguments for <span class="math notranslate nohighlight">\(M[X]\)</span></p></li>
<li><p><strong>Ewald</strong> (<em>RPYVelocityEvaluator object</em>) – Used to call the GPU PSE function to compute <span class="math notranslate nohighlight">\(M^{1/2}\)</span> (for
nonlocal hydro only)</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em>) – Specifies the periodic domain when doing nonlocal hydro</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Two arrays of size <span class="math notranslate nohighlight">\(3FN_x\)</span> (3 times the total number of Chebyshev
points). The first array is <span class="math notranslate nohighlight">\(M^{1/2}W\)</span>, and the second is <span class="math notranslate nohighlight">\(M^{-1/2}W\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(array,array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.SemiflexiblefiberCollection.StepToMidpoint">
<span class="sig-name descname"><span class="pre">StepToMidpoint</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">MHalfEta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.SemiflexiblefiberCollection.StepToMidpoint" title="Permalink to this definition">¶</a></dt>
<dd><p>This function steps to the midpoint by inverting K. Specifically, we are computing
<div class="math notranslate nohighlight">
\[\alpha^*= K^\dagger \sqrt{\frac{2k_BT}{\Delta t}}M^{1/2}W,\]</div>

and then evolving the fiber to the “midpoint”
by taking a step of size <span class="math notranslate nohighlight">\(\Delta t/2\)</span> using tangent vector rotation rates
<span class="math notranslate nohighlight">\(\alpha^*=\left(\Omega^*,U_{mp}^*\right)\)</span></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>MHalfEta</strong> (<em>array</em>) – This is <span class="math notranslate nohighlight">\(M[X]^{1/2}W\)</span>, obtained using the previous method</p></li>
<li><p><strong>dt</strong> (<em>double</em>) – The time step size</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Three arrays which represent the tangent vectors <span class="math notranslate nohighlight">\(\tau^{n+1/2,*}\)</span>,
fiber midpoints <span class="math notranslate nohighlight">\(X_{mp}^{n+1/2,*}\)</span>, and fiber positions
<span class="math notranslate nohighlight">\(X^{n+1/2,*}\)</span> which are obtained via the update with <span class="math notranslate nohighlight">\(\alpha^*\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(array, array, array)</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.SemiflexiblefiberCollection.DriftPlusBrownianVel">
<span class="sig-name descname"><span class="pre">DriftPlusBrownianVel</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XMidTime</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MHalfEta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">MMinusHalfEta</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ModifyBE</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RPYEval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.SemiflexiblefiberCollection.DriftPlusBrownianVel" title="Permalink to this definition">¶</a></dt>
<dd><p>The purpose of this method is to return the velocity that goes on the RHS of the saddle
point system for fluctuating fibers. This has three components to it:</p>
<ol class="arabic simple">
<li><p>The Brownian velocity <span class="math notranslate nohighlight">\(\sqrt{\frac{2k_BT}{\Delta t}}M^{1/2}W\)</span></p></li>
<li><p>The extra term <span class="math notranslate nohighlight">\(\sqrt{k_B T} ML^{1/2}W\)</span> that comes in when we use modified backward Euler, see
(8.20) in Maxian’s PhD thesis. Here <span class="math notranslate nohighlight">\(L\)</span> is the bending energy matrix.</p></li>
<li><p>The stochastic drift velocity necessary to ensure we sample from the correct
equilibrium distribution.
The formula for the drift term depends on the type of hydrodynamics being considered.
If we are considering only LOCAL hydrodynamics (no inter-fiber communication), it is
given by
<div class="math notranslate nohighlight">
\[U_{MD}=\sqrt{\frac{2 k_B T}{\Delta t}} \left(M^{n+1/2,*}-M^n\right)\left(M^n\right)^{-T/2}\eta,\]</div>

where <span class="math notranslate nohighlight">\(\eta \sim\)</span>randn(0,1) and this formula is computed using dense linear algebra on
each fiber separately.
In the case when there is inter-fiber hydrodynamics, this resistance problem becomes
expensive, and so we use an alternative approach, computing
<div class="math notranslate nohighlight">
\[U_{MD} = \frac{k_B T}{\delta L} \left(M\left(\tau^{(RFD)}\right)-M\left(\tau^n\right)\right)\eta\]</div>

where the RFD for <span class="math notranslate nohighlight">\(\tau\)</span> is obtained by computing <span class="math notranslate nohighlight">\(\mu=K^\dagger \eta\)</span> and rotating
<span class="math notranslate nohighlight">\(\tau^n\)</span> by the oriented angle <span class="math notranslate nohighlight">\(\delta L \mu\)</span>. Here we use <span class="math notranslate nohighlight">\(\delta=10^{-5}\)</span> as the
small parameter in this random finite difference.
For more details on this, see formulas (8.31) and (8.32) in Maxian’s PhD thesis.</p></li>
</ol>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>XMidTime</strong> (<em>array</em>) – The positions <span class="math notranslate nohighlight">\(X^{n+1/2,*}\)</span> at all Chebyshev points</p></li>
<li><p><strong>MHalfEta</strong> (<em>array</em>) – The Brownian velocity <span class="math notranslate nohighlight">\(M^{1/2}W\)</span> at all Chebyshev points</p></li>
<li><p><strong>MMinusHalfEta</strong> (<em>array</em>) – The Brownian velocity <span class="math notranslate nohighlight">\(M^{-1/2}W\)</span> at all Chebyshev points (this
is only necessary when we use the first formula for the drift term –
local hydrodynamics only)</p></li>
<li><p><strong>dt</strong> (<em>double</em>) – Time step size</p></li>
<li><p><strong>ModifyBE</strong> (<em>bool</em>) – Whether to include in the velocity the term <span class="math notranslate nohighlight">\(\sqrt{k_B T} ML^{1/2}W\)</span>
for modified backward Euler</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em>) – Specifies the periodic domain when doing nonlocal hydro</p></li>
<li><p><strong>RPYEval</strong> (<em>RPYVelocityEvaluator object</em>) – Used to call the GPU PSE function to apply <span class="math notranslate nohighlight">\(M\)</span> (for
nonlocal hydro only)</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>The total velocity to be treated explicitly in the saddle point
solve, which is simply the sum of terms 1-3 above.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.SemiflexiblefiberCollection.Mobility">
<span class="sig-name descname"><span class="pre">Mobility</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">LamAlph</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">impcodt</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">X</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Xs</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Dom</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">RPYEval</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.SemiflexiblefiberCollection.Mobility" title="Permalink to this definition">¶</a></dt>
<dd><p>Mobility calculation for GMRES. This method takes <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> and computes
<div class="math notranslate nohighlight">
\[\begin{split}
\begin{pmatrix}
-M \left(c \Delta t F K \alpha + \Lambda \right) \\
K^T \Lambda
\end{pmatrix}
\end{split}\]</div>

In other words, it computes the total forcing from <span class="math notranslate nohighlight">\(\alpha\)</span> and <span class="math notranslate nohighlight">\(\Lambda\)</span> (which
is given by <span class="math notranslate nohighlight">\(c \Delta t F K \alpha + \Lambda \)</span>) and then applies the TOTAL
(local and nonlocal) mobility to that. This differs from the deterministic class
because here we just use the oversampled velocity on the GPU as
the ENTIRE velocity (local + nonlocal). So, when we call the method nonLocalVelocity,
we set the argument subself=False, since the self term is treated using Ewald splitting
just like the inter-fiber hydrodynamic terms. Here we need to do GMRES, so obviously
we are in a situation where self._nonLocal=1 (we have interfiber hydrodynamics).</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>LamAlph</strong> (<em>array</em>) – The input for <span class="math notranslate nohighlight">\(\Lambda\)</span> and <span class="math notranslate nohighlight">\(\alpha\)</span> (in that order)</p></li>
<li><p><strong>impcodt</strong> (<em>double</em>) – <span class="math notranslate nohighlight">\(\Delta t \times c\)</span>, here <span class="math notranslate nohighlight">\(c\)</span> is the implicit coefficient.
The implicit coefficient <span class="math notranslate nohighlight">\(c\)</span> depends on the
temporal integrator being used.</p></li>
<li><p><strong>X</strong> (<em>array</em>) – The Chebyshev points for the fibers</p></li>
<li><p><strong>Xs</strong> (<em>array</em>) – The tangent vectors for the fibers</p></li>
<li><p><strong>Dom</strong> (<em>Domain object</em>) – Sets the periodic domain for the velocity calculation.</p></li>
<li><p><strong>RPYEval</strong> (<em>RPYVelocityEvaluator object</em>) – Computes the velocity from a set of blobs.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>An array with two components: the first block is the velocity (see docstring above) and
the second block is <span class="math notranslate nohighlight">\(K^T \Lambda\)</span></p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="fiberCollection.SemiflexiblefiberCollection.FiberStress">
<span class="sig-name descname"><span class="pre">FiberStress</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">XBend</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">XLam</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Tau_n</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">Volume</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#fiberCollection.SemiflexiblefiberCollection.FiberStress" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute fiber stress. The formula for the deterministic
stress for a given force is
$$ \sigma = \frac{1}{V}\sum_j X_j F_j^T,$$
where <span class="math notranslate nohighlight">\(j\)</span> refers to the index of Chebyshev points and <span class="math notranslate nohighlight">\(V\)</span>
is the domain volume. In this subclass, we also compute
a Brownian part to the stress, which is given by the formula
<div class="math notranslate nohighlight">
\[\frac{\partial S_{ij}}{\partial X_k} K_{ka}K^{-1}_{aj},\]</div>

where <span class="math notranslate nohighlight">\(S[X]\)</span> is the <span class="math notranslate nohighlight">\(9 \times 3N_x\)</span> tensor that gives stress from the
forces on the Chebyshev points. This formula has NOT been verified or
tested, but is included here for completeness.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters<span class="colon">:</span></dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>XBend</strong> (<em>array</em>) – The locations to use to compute the bending force</p></li>
<li><p><strong>XLam</strong> (<em>array</em>) – The locations to use to compute the stress from <span class="math notranslate nohighlight">\(\Lambda\)</span>
(which is saved as an internal variable). In order for the
stress to be symmetric, these locations have to be the same
as the one used in the solve <span class="math notranslate nohighlight">\(K[X]^T \Lambda=0\)</span>, which means
they could be different from the bend locations.</p></li>
<li><p><strong>Tau_n</strong> (<em>array</em>) – Tangent vectors at time n.</p></li>
<li><p><strong>Volume</strong> (<em>double</em>) – The volume of the domain on which we are computing the stress.</p></li>
</ul>
</dd>
<dt class="field-even">Returns<span class="colon">:</span></dt>
<dd class="field-even"><p>Three 3 x 3 matrices of stress. The first is the stress
from the bend forces, the second the stress from <span class="math notranslate nohighlight">\(\Lambda\)</span>, and
the third is the stochastic drift stress.</p>
</dd>
<dt class="field-odd">Return type<span class="colon">:</span></dt>
<dd class="field-odd"><p>(array,array,array)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>



            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <div>
    <h3><a href="index.html">Table of Contents</a></h3>
    <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">fiberCollection</span></code></a><ul>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.__init__"><code class="docutils literal notranslate"><span class="pre">__init__()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.initFibList"><code class="docutils literal notranslate"><span class="pre">initFibList()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.RSAFibers"><code class="docutils literal notranslate"><span class="pre">RSAFibers()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.initPointForceVelocityArrays"><code class="docutils literal notranslate"><span class="pre">initPointForceVelocityArrays()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.fillPointArrays"><code class="docutils literal notranslate"><span class="pre">fillPointArrays()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.formBlockDiagRHS"><code class="docutils literal notranslate"><span class="pre">formBlockDiagRHS()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.calcResidualVelocity"><code class="docutils literal notranslate"><span class="pre">calcResidualVelocity()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.CheckResiduals"><code class="docutils literal notranslate"><span class="pre">CheckResiduals()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.Mobility"><code class="docutils literal notranslate"><span class="pre">Mobility()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.FactorizePreconditioner"><code class="docutils literal notranslate"><span class="pre">FactorizePreconditioner()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.BlockDiagPrecond"><code class="docutils literal notranslate"><span class="pre">BlockDiagPrecond()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.BrownianUpdate"><code class="docutils literal notranslate"><span class="pre">BrownianUpdate()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.nonLocalVelocity"><code class="docutils literal notranslate"><span class="pre">nonLocalVelocity()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.updateLambdaAlpha"><code class="docutils literal notranslate"><span class="pre">updateLambdaAlpha()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.updateAllFibers"><code class="docutils literal notranslate"><span class="pre">updateAllFibers()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getX"><code class="docutils literal notranslate"><span class="pre">getX()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getXs"><code class="docutils literal notranslate"><span class="pre">getXs()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.FiberStress"><code class="docutils literal notranslate"><span class="pre">FiberStress()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.uniformForce"><code class="docutils literal notranslate"><span class="pre">uniformForce()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getUniformPoints"><code class="docutils literal notranslate"><span class="pre">getUniformPoints()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getPointsForUpsampledQuad"><code class="docutils literal notranslate"><span class="pre">getPointsForUpsampledQuad()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getForcesForUpsampledQuad"><code class="docutils literal notranslate"><span class="pre">getForcesForUpsampledQuad()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getDownsampledVelocity"><code class="docutils literal notranslate"><span class="pre">getDownsampledVelocity()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getg"><code class="docutils literal notranslate"><span class="pre">getg()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getSysDimension"><code class="docutils literal notranslate"><span class="pre">getSysDimension()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.averageTangentVectors"><code class="docutils literal notranslate"><span class="pre">averageTangentVectors()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.initializeLambdaForNewFibers"><code class="docutils literal notranslate"><span class="pre">initializeLambdaForNewFibers()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.FiberBirthAndDeath"><code class="docutils literal notranslate"><span class="pre">FiberBirthAndDeath()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.writeFiberLocations"><code class="docutils literal notranslate"><span class="pre">writeFiberLocations()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.SubtractSelfTerms"><code class="docutils literal notranslate"><span class="pre">SubtractSelfTerms()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.LocalVelocity"><code class="docutils literal notranslate"><span class="pre">LocalVelocity()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.evalU0"><code class="docutils literal notranslate"><span class="pre">evalU0()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.evalBendForce"><code class="docutils literal notranslate"><span class="pre">evalBendForce()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.calcCurvatures"><code class="docutils literal notranslate"><span class="pre">calcCurvatures()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getXInds"><code class="docutils literal notranslate"><span class="pre">getXInds()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getTauInds"><code class="docutils literal notranslate"><span class="pre">getTauInds()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.fiberCollection.getStackInds"><code class="docutils literal notranslate"><span class="pre">getStackInds()</span></code></a></li>
</ul>
</li>
<li><a class="reference internal" href="#fiberCollection.SemiflexiblefiberCollection"><code class="docutils literal notranslate"><span class="pre">SemiflexiblefiberCollection</span></code></a><ul>
<li><a class="reference internal" href="#fiberCollection.SemiflexiblefiberCollection.__init__"><code class="docutils literal notranslate"><span class="pre">__init__()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.SemiflexiblefiberCollection.formBlockDiagRHS"><code class="docutils literal notranslate"><span class="pre">formBlockDiagRHS()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.SemiflexiblefiberCollection.BrownianUpdate"><code class="docutils literal notranslate"><span class="pre">BrownianUpdate()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.SemiflexiblefiberCollection.MHalfAndMinusHalfEta"><code class="docutils literal notranslate"><span class="pre">MHalfAndMinusHalfEta()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.SemiflexiblefiberCollection.StepToMidpoint"><code class="docutils literal notranslate"><span class="pre">StepToMidpoint()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.SemiflexiblefiberCollection.DriftPlusBrownianVel"><code class="docutils literal notranslate"><span class="pre">DriftPlusBrownianVel()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.SemiflexiblefiberCollection.Mobility"><code class="docutils literal notranslate"><span class="pre">Mobility()</span></code></a></li>
<li><a class="reference internal" href="#fiberCollection.SemiflexiblefiberCollection.FiberStress"><code class="docutils literal notranslate"><span class="pre">FiberStress()</span></code></a></li>
</ul>
</li>
</ul>

  </div>
  <div>
    <h4>Previous topic</h4>
    <p class="topless"><a href="TemporalIntegrator.html"
                          title="previous chapter">Members</a></p>
  </div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/fiberCollection.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="TemporalIntegrator.html" title="Members"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">SPARCLE 1.0 documentation</a> &#187;</li>
          <li class="nav-item nav-item-1"><a href="PythonClasses.html" >Python Classes</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">&lt;no title&gt;</a></li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2023, Ondrej Maxian, Raul P. Perez, Aleksandar Donev.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 6.2.1.
    </div>
  </body>
</html>