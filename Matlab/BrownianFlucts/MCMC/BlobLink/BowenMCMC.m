clear; close all;
% settings
alpha_num = 10;                 % the number of angles in one chain
kappas = [2; 1; 0.5; 0.2; 0.1]; % kappa = l_p/L = persistence length / contour length = 1/t
sample_num = 10^6;              % the number of samples to be generated in each iteration
itr = 10;                       % the total number of such iterations ( > 1 )
use_vMF = 0;                    % whether to generate the next vector during sampling 
                                % by directly rotating the previous vector or to 
                                % use the von Misesâ€“Fisher distribution as the proposal function
plot_shapes = 0;                % whether or not to plot shapes in the place of distribution curves 
                                % in the comparison plot

shapes = ['^', 'd', 's', 'o', '<']; % the shapes to be plotted in the comparison plot
plots = [];                         % the distribution curves generated by Metropolis sampling
kappa_num = length(kappas);         % the number of values of kappa

set_up_plots(kappa_num);

% start sampling
for j = 1:length(kappas)
    kappa = kappas(j);                      % the value of kappa to be used
    bin_width = 0.01;
    x = 0:bin_width:1;                      % the ranges of bins
    result_matrix = zeros(itr, length(x)-1);% the values at each bin in each iteration
    for k = 1:itr
        make_plots = k == 1;                % produce the additional plots only in the first iteration
        % use the Metropolis sampler to obtain chain samples
        % samples = vectors; alphas = the angles between the vectors
        [samples, alphas] = Metropolis_sampler(alpha_num, kappa, sample_num, use_vMF, make_plots);
        if make_plots; plot_before_removal(alphas, kappa); end
        % remove the first 100 samples and pick 1 in every 10 samples afterwards
        samples = samples(:, :, 100:10:end);
        alphas = alphas(100:10:end, :);
        if make_plots; plot_after_removal(samples, alphas, kappa); end
        % compute the endpoint distance of each sample chain and rescale the range to [0, 1]
        r = vecnorm(sum(samples));
        r = reshape(r, 1, []) / (alpha_num + 1);
        % compute and normalize r^2 * frequency in [0, 1]
        x = 0:bin_width:1;              % the ranges of bins
        frequency = histc(r, x);        % the number of samples whose r is within each bin
        x = x(1:end-1) + bin_width/2;   % shift from the left endpoint to the center of each bin
        frequency = frequency(1:end-1); % discard the rightmost bin
        y = frequency .* (x.^2);        % multiply by r^2
        C = trapz(x, y);                % normalize the area
        result_matrix(k, :) = y./C;
    end
    % plot the distribution curve from the results of all the iterations with the current value of kappa
    plots = main_plot(x, result_matrix, j, shapes(j), plot_shapes, plots);
end
% complete the comparison plot
xlim([0 1]);
ylim([0 14]);
set(gca, 'ColorOrderIndex', 1);
xlabel('$$r$$', 'interpreter', 'latex');
ylabel('$$4 \pi r^2 G(r)$$', 'interpreter', 'latex');
labels = [strcat('$$\kappa=', num2str(kappas, '%.1f'), '$$   MCMC')];
legend(plots, labels, 'interpreter', 'latex', 'Location', 'northwest');
title('Comparison with the theoretical solution');
theoretical;    % compute and plot the theoretical distribution

%% Metropolis sampler

function [sample, alpha, acceptance_rate] = Metropolis_sampler(alpha_num, kappa, itr, vMF, make_plot)
    L = alpha_num + 1;                      % contour length
    beta = 2 * kappa * L;                   % coefficient in the exponent
    f = @(alpha) exp(sum(-beta .* (sin(alpha/2).^2))); % proportional to the target pdf
    sample = zeros(L, 3, itr);              % the vector components of each sample chain
    alpha = zeros(itr, alpha_num);          % the angles between each pair of the consecutive vectors
    [alpha(1, :), sample(:, :, 1)] = generate_initial_chain(alpha_num); % arbitrary initial value
    current_f = f(alpha(1, :));             % f evaluated at the current set of alphas
    accept_counter = 1;                     % the total number of accepted samples
    acceptance_rate = [1, zeros(1, itr-1)]; % the cumulative acceptance rate
    for t = 2:itr
        % choose an appropriate variance for the proposal function
        if ~vMF
            if kappa >= 1; angle_std = 0.15 / kappa; else; angle_std = 0.1 / kappa; end
        else
            if kappa >= 1; angle_std = 0.1 / kappa; else; angle_std = 0.05 / kappa; end
        end
        % obtain a candidate sample using the proposal function
        [alphas, candidate] = propose_next_candidate(sample(:, :, t-1), alpha_num, angle_std, vMF);
        % accept or reject
        accept_ratio = f(alphas) / current_f;
        % accept the candidate with probability min(accept_ratio,1)
        u = rand();     % uniform random number in [0,1]
        if u <= accept_ratio
            % accept the candidate and update the variables
            sample(:, :, t) = candidate;
            alpha(t, :) = alphas;
            current_f = f(alphas);
            accept_counter = accept_counter + 1;
        else
            % reject the candidate and continue to use the previous sample
            sample(:, :, t) = sample(:, :, t-1);
            alpha(t, :) = alpha(t-1, :);
        end
        acceptance_rate(t) = accept_counter / t;
    end
    if make_plot; plot_acceptance_rate(acceptance_rate(1:min(2*10^3, itr)), kappa); end

    % generate an arbitrary chain as the initial sample
    function [alphas, vectors] = generate_initial_chain(num)
        vectors = randn(num+1, 3);
        vectors = vectors ./ vecnorm(vectors, 2, 2);
        alphas = zeros(1, num);
        for i = 1:num
            alphas(i) = acos(dot(vectors(i, :), vectors(i+1, :)));
        end
%         plot_chain(vectors);
    end

    % use the proposal distribution to randomly select the next candidate sample
    function [alphas, vectors] = propose_next_candidate(prev, num, angle_std, vMF)
        % method 1: directly rotate the vector around a random axis by a gaussian angle
        function out = randRotation(vector, angle_std)
            axis = randn(1, 3);
            axis = axis / norm(axis);
            angle = angle_std * randn(1);
            % apply Rodrigues' rotation formula
            out = vector*cos(angle)+cross(axis,vector)*sin(angle)+axis*dot(axis,vector)*(1-cos(angle));
        end
        % method 2: generate a random vector that follows vMF around the unit vector along the z axis, 
        %           and then rotate it to make the input vector as the center of the distribution
        function out = randVMF(mu, kappa)
            % Sample from the vMF distibution
            % taken from: https://www.mitsuba-renderer.org/~wenzel/files/vmf.pdf

            % Uniform V
            V = randn(2,1);
            V = V./sqrt(sum(V.^2));

            % Inverse CDF for W
            xi = rand(1);
            W = 1 + (1.0/kappa)*log(xi + (1- xi)*exp(-2*kappa));

            W_pole = [sqrt(1-W.^2).*V; W];

            axis = cross([0;0;1],mu);
            axis = axis./norm(axis);
            cos_th = dot(mu,[0;0;1]);
            sin_th = sqrt(1 - cos_th^2);

            out = cos_th*W_pole + sin_th*(cross(axis,W_pole)) + (1-cos_th)*dot(axis,W_pole)*axis;
        end
        
        alphas = zeros(1, num);
        vectors = zeros(num+1, 3);
        for i = 1:(num+1)
            if ~vMF
                vectors(i, :) = randRotation(prev(i, :), angle_std);
            else
                vectors(i, :) = randVMF(prev(i, :)', 1/angle_std^2)';
            end
            if i >= 2
                alphas(i-1) = acos(dot(vectors(i-1, :), vectors(i, :)));
            end
        end
%         plot_chain(vectors);
    end
end

%% generate a random chain with the given angles & compute its endpoint distance
% (used when the angles are directly sampled without using vectors)
function dist = compute_dist(alphas)
    vectors = zeros(length(alphas)+1, 3); % the number of vectors is (the number of angles + 1)
    vectors(1, :) = [1, 0, 0];            % the first unit vector is arbitrarily initialized
    % compute the next vector based on the previous vector
    for i = 1:length(alphas)
        orthogonal_vector = zeros(1, 3);  % will find a random vector prependicular to the previous vector
        while ~any(orthogonal_vector)     % the random vector cannot be zero vector
            rand_vector = randn(1, 3);    % generate a random vector
            orthogonal_vector = cross(vectors(i, :), rand_vector);
            orthogonal_vector = orthogonal_vector / norm(orthogonal_vector);
            % the cross product of the original vector and the random vector will be perpendicular to both
            % (the cross product is the zero vector if the two vectors above happen to be parallel, 
            %  in which case we discard the result and regenerate the orthogonal vector)
        end
        % generate the next vector based on the previous vector and the random vector perpendicular to it
        vectors(i+1, :) = cos(alphas(i)) * vectors(i, :) + sin(alphas(i)) * orthogonal_vector;
    end
    % add all the vectors to obtain the relative position of the two endpoints of the chain
    vector_sum = sum(vectors, 1);
    dist = norm(vector_sum);              % compute the Euclidean distance between the two endpoints
%     plot_chain(vectors);
end

%% validation functions

function check_alpha_distribution(alphas, kappa)
    % determine whether or not to plot the alpha distribution at each position of the chain
    kappas_to_be_checked = [2];
    plot_alpha_at_each_position = ismember(kappa, kappas_to_be_checked);

    % check the distribution of all alphas
    alpha_num = size(alphas, 2);    % the number of angles in one chain
    L = alpha_num + 1;              % contour length
    beta = 2 * kappa * L;           % coefficient in the exponent
    f = @(alpha) sin(alpha).*exp(-beta * sin(alpha/2).^2); % proportional to the target pdf
    boundary = pi;                  % the right boundary of the alpha distribution
    bin_width = 0.1;
    x = 0:bin_width:boundary;
    frequency = zeros(alpha_num, length(x)-1);
    if plot_alpha_at_each_position
        f_ = figure;
        f_.Position = [200 200 900 450];
        t = tiledlayout(min(3, alpha_num), max(ceil(alpha_num / 3), 1), 'TileSpacing','Compact');
        t.Title.String = ['The distributions of the angles at different positions, kappa = ' ...
            num2str(kappa)];
    end
    for i = 1:alpha_num
        if plot_alpha_at_each_position
            nexttile; hold on;
            histogram(alphas(:, i), x, 'Normalization', 'pdf', ...
                'DisplayStyle', 'stairs');      % observed distribution
            area = integral(f, 0, boundary);    % normalizing constant
            plot(x, f(x)./area, 'LineWidth', 1) % theoretical distribution
            legend(['alpha ' num2str(i)], 'Location', 'northeast');
        end
        frequency(i, :) = histcounts(alphas(:, i), x, 'Normalization', 'pdf');
    end
    % plot the distribution of all alphas
    figure(7); hold on;
    x_ = x(1:end-1) + bin_width/2;                % shift from the left endpoint to the center of each bin
    errorbar(x_, mean(frequency), std(frequency));% observed distribution
    area = integral(f, 0, boundary);              % normalizing constant
    plot(x, f(x)./area, 'LineWidth', 1)           % theoretical distribution
    xlabel('$$\alpha$$', 'interpreter', 'latex');
    ylabel('Density');
    legend('observed', 'theoretical');
    title(['$$f(\alpha) = \exp(-' num2str(beta) '\cdot \sin^2(\alpha/2))$$'], 'interpreter', 'latex');
end

function check_alpha_correlation_in_the_same_chain(alphas)
    mean_alphas = mean(alphas(:));
    xcorr_result = zeros(size(alphas));
    % autocorr in each individual chain
    for i = 1:size(alphas, 1)
        xcorr_result_ = xcorr(alphas(i, :) - mean_alphas, 'unbiased');
        xcorr_result(i, :) = xcorr_result_(size(alphas, 2):end);
    end
    avg_xcorr = mean(xcorr_result);
    % plot the average autocorr
    plot(0:1:size(alphas, 2)-1, avg_xcorr, 'r.', 'MarkerSize', 15);
    xlim([0, size(alphas, 2)-1]);
    xlabel('Lag');
    ylabel('Correlation');
    grid on; hold on;
    line(xlim, [0,0], 'Color', 'k', 'LineWidth', 1);    % x axis
    % the vertical line from each point to the x axis
    for i = 1:length(avg_xcorr)
        line([i-1, i-1], [0, avg_xcorr(i)], 'Color', 'r', 'LineWidth', 0.5);
    end
end

function check_vector_correlation_in_the_same_chain(vectors, coef)
    xcorr_result = zeros(size(vectors, 3), size(vectors, 2), size(vectors, 1));
%     means = zeros(1, 3);
%     for j = 1:3
%         total = 0;
%         for i = 1:size(vectors, 3)
%             total = total + sum(vectors(:, j, i));
%         end
%         means(j) = total / (size(vectors, 1)*size(vectors, 3));
%     end
    % autocorr in each individual chain
    for i = 1:size(vectors, 3)
        for j = 1:3
            xcorr_result_ = xcorr(vectors(:, j, i), 'unbiased');
            xcorr_result(i, j, :) = xcorr_result_(size(vectors, 1):end);
        end
    end
    sum_xcorr_result = sum(xcorr_result, 2);
    avg_xcorr = mean(sum_xcorr_result);
    avg_xcorr = avg_xcorr(:);
    % plot the average autocorr
    plot(0:1:size(vectors, 1)-1, avg_xcorr, 'r.', 'MarkerSize', 15);
    xlim([0, size(vectors, 1)-1]);
    xlabel('k', 'interpreter', 'latex');
    ylabel('Correlation');
    grid on; hold on;
    line(xlim, [0,0], 'Color', 'k', 'LineWidth', 1);    % x axis
    % error bars
    std_xcorr = std(sum_xcorr_result);
    std_xcorr = std_xcorr(:);
    errorbar(0:1:size(vectors, 1)-1, avg_xcorr, std_xcorr*2./sqrt(size(sum_xcorr_result, 1)), 'r', ...
        'LineStyle', 'none');
    % the vertical line from each point to the x axis
    for i = 1:length(avg_xcorr)
        line([i-1, i-1], [0, avg_xcorr(i)], 'Color', 'r', 'LineWidth', 0.5);
    end
    plot(0:1:size(vectors, 1)-1, exp(-(0:1:size(vectors, 1)-1)*coef), 'r');
    title(['$$\langle \tau_i \cdot \tau_{i+k} \rangle = \exp(-k/' num2str(1/coef) ')$$'], ...
        'interpreter', 'latex');
end

function check_vector_dot_product_distribution(vectors, kappa)
    chain_num = size(vectors, 3);
    vector_num = size(vectors, 1);
    mean_dot_product = zeros(1, vector_num);
    std_dot_product = zeros(1, vector_num);
    for k = 0:vector_num - 1
        dot_product = zeros(chain_num, vector_num - k);
        for i = 1:chain_num
            for j = 1:vector_num - k
                dot_product(i, j) = dot(vectors(j, :, i), vectors(j + k, :, i));
            end
        end
        mean_dot_product(k+1) = mean(dot_product(:));
        std_dot_product(k+1) = std(dot_product(:));
    end
    figure; hold on;
    k = 0:vector_num - 1;
    errorbar(k, mean_dot_product, std_dot_product*2./sqrt((chain_num)*(vector_num - k)));
    plot(k, exp(-k * 1 / (kappa*(vector_num))));
    legend('observed', '$$\exp(-\frac{kl}{l_p})$$', 'interpreter', 'latex');
    title(['The distribution of the dot product of vectors, $$\kappa = ' num2str(kappa) '$$'], ...
        'interpreter', 'latex');
end

%% Generate plots

function set_up_plot(index, title, plot_num)
    f = figure(index);
    f.Position = [200 200 900 450];
    t = tiledlayout(min(2, plot_num), max(ceil(plot_num / 2), 1), 'TileSpacing','Compact');
    t.Title.String = title;
end

function set_up_plots(kappa_num)
    figure(1); hold on;
    set_up_plot(2, ['Sample acceptance rates in the first 2000 iterations'], kappa_num);
    set_up_plot(3, ['The autocorrelation of the first angle across samples ' ...
        'without removing any samples'], kappa_num);
    set_up_plot(4, {'The autocorrelation of the first angle across samples ', ...
        'after removing the first 100 samples & picking 1 in every 10 samples'}, kappa_num);
    set_up_plot(5, {'The average autocorrelation of the middle angle across samples ', ...
        'after removing the first 100 samples & picking 1 in every 10 samples'}, kappa_num);
    set_up_plot(6, ['The correlation of the angles within the same chain'], kappa_num);
    set_up_plot(7, ['The distribution of alpha in all samples'], kappa_num);
    set_up_plot(8, ['The autocorrelation of the vector products within the same chain'], kappa_num);
end

function plots = main_plot(x, result_matrix, j, shape, plot_shape, plots)   % the comparison plot
    figure(1);
    colors = get(gca,'colororder');
    if ~plot_shape  % plot solid curves
        plots = [plots plot(x, mean(result_matrix), 'Color', colors(j, :))];
    end
    % sparsify the points to be plotted
    result_matrix = result_matrix(:, [1:3:91 93:2:100]);
    x = x([1:3:91 93:2:100]);
    if plot_shape   % plot shapes instead of curves
        plots = [plots plot(x, mean(result_matrix), shape, 'MarkerSize', 5, 'Color', colors(j, :))];
    end
    % plot the error bars
    std_ = std(result_matrix);
    errorbar(x, mean(result_matrix), std_*2./sqrt(size(result_matrix, 1)), 'LineStyle', 'none', ...
        'Color', colors(j, :));
end

function plot_acceptance_rate(acceptance_rate, kappa)   % the plot of the cumulative acceptance rate
    figure(2);
    nexttile;
    plot(acceptance_rate);
    ylim([0 1]);
    xlabel('Iteration');
    ylabel('Acceptance rate');
    legend(['$$\kappa = ' num2str(kappa) '$$'], 'Location', 'southwest', 'interpreter', 'latex');
end

function plot_before_removal(alphas, kappa) % the plot of the autocorrelation before removing any sample
    figure(3);
    nexttile;
    autocorr(alphas(:, 1), 100);
    xlim([0 100]);
    legend(['$$\kappa = ' num2str(kappa) '$$'], 'Location', 'northeast', 'interpreter', 'latex');
    title('');
end

function plot_after_removal(vectors, alphas, kappa)  % plot the remaining plots after removing some samples
    label = ['$$\kappa = ' num2str(kappa) '$$'];
    % autocorrelation plot of the first angles
    figure(4);
    nexttile;
    autocorr(alphas(:, 1), 100);
    xlim([0 100]);
    legend(label, 'Location', 'northeast', 'interpreter', 'latex');
    title('');
    % autocorrelation plot of the middle angles
    figure(5);
    nexttile;
    autocorr(alphas(:, round(size(alphas, 2)/2)), 100);
    xlim([0 100]);
    legend(label, 'Location', 'northeast', 'interpreter', 'latex');
    title('');
    % average autocorrelation of the angles within the chain
    figure(6);
    nexttile;
    check_alpha_correlation_in_the_same_chain(alphas);
    legend(label, 'Location', 'northeast', 'interpreter', 'latex');
    % distribution of all angles
    figure(7);
    nexttile;
    check_alpha_distribution(alphas, kappa);
    legend(label, 'Location', 'northeast', 'interpreter', 'latex');
    % distribution of vector products
    figure(8);
    nexttile;
    check_vector_correlation_in_the_same_chain(vectors, 1 / (kappa*size(vectors, 1)));
    legend(label, 'Location', 'northeast', 'interpreter', 'latex');
    check_vector_dot_product_distribution(vectors, kappa);
end

function plot_chain(vectors)    % plot a sample chain
    max_plot = 15;
    if length(findobj('type','figure')) < max_plot
        figure;
    else
        figure(max_plot);
    end
    startpoint = [0, 0, 0];
    for i = 1:size(vectors, 1)
        quiver3(startpoint(1), startpoint(2), startpoint(3), vectors(i, 1), vectors(i, 2), ...
            vectors(i, 3), 0, 'LineWidth', 2);
        startpoint = startpoint + vectors(i, :);
        hold on;
    end
    grid on; axis equal;
    vector_sum = sum(vectors, 1);   % the vector connecting the two endpoints of the chain
    quiver3(0, 0, 0, vector_sum(1), vector_sum(2), vector_sum(3), 0);
    xlabel('x');
    ylabel('y');
    zlabel('z');
    title(['Random chain consisting of ' num2str(size(vectors, 1)) ' unit vectors']);
end